<!-- uses https://highlightjs.org/
-->

<html>
  <head>
    <link
      rel="shortcut icon"
      href="https://byui-cse.github.io/Language-Courses/site/images/fav.ico"
      type="image/x-i        con"
    />
    <script type="text/javascript">
      var codeType = "Swift";
    </script>
    <script src="https://byui-cse.github.io/Language-Courses/site/highlight.pack.js"></script>
    <link
      rel="stylesheet"
      href="https://byui-cse.github.io/Language-Courses/site/highlight_styles/xcode.css"
    />
    <link
      rel="stylesheet"
      href="https://byui-cse.github.io/Language-Courses/site/weekly.css"
    />
    <script
      type="text/javascript"
      src="https://byui-cse.github.io/Language-Courses/site/weekly.js"
    ></script>
    <link rel="stylesheet" href="../main.css" />
  </head>

  <body onload="fetchSource()">
    <header class="hero-image">
      <section class="hero-text">
        <h1>CSE 222a: Week 03</h1>
        <p>Representing Data</p>
      </section>
    </header>
    <main>
      <h1>Language Organization and Access</h1>
      <p>
        All computer languages are ways to organize your communication and
        thinking. In this, they are very similar to spoken languages. Each
        spoken language, or family of spoken languages, does this organization
        differently. English sentences often have a structure of Subject-Helper
        Verb-Verb-Predicate structure, such as "The boy will bite the dog," for
        example. German, a language closely related to English, organizes things
        differently. Sometimes German sentences have a Subject-Helper
        Verb-Predicate-Verb structure... "Ich werde das Buch bald lesen," which
        if translated word-by-word is "I will the book soon read." Spanish has
        adjectives after the nouns they modify.
      </p>
      <p>
        While each language has its own organizational rules, they all do the
        same thing. They allow us to organize and express our thinking.
      </p>
      <h3>Instances of Classes - another organizational concept of Swift</h3>
      <p>
        Since Swift has the language Haskell as an ancestor, Swift, like
        Haskell, has the concept of functions. But Haskell isn't Swift's only
        ancestor. Ruby and C# are both OO languages and ancestors of Swift.
        That's why classes and their instances are a way to organize your data
        and code in Swift.
      </p>
      <p>
        Don't get carried away. Some languages don't have stand-alone functions
        (Java) or strongly discourage their use (C++). This is not so in Swift.
        When you begin thinking in Swift you will mix and mingle functions,
        classes and instances of classes, and a few other ways of organizing
        your data we'll cover below. The rule for Swift is simple. Write your
        code in the way that best and most clearly describes what you are trying
        to do. If that's a function, use a function. If that's a class and
        instances of the class, do that.
      </p>
      <p>
        A note about naming conventions: as mentioned last week, variable, constant 
        and function names in Swift are written in camelCase like anInt and myString. 
        Type names including Classes, Structs and Protocols have their first letter 
        capitalized like Double, Array and MedicationContainer.
      </p>

      <h1>The Situation</h1>
      <p>
        To help learn about the
        <a
          href="https://www.tutlane.com/tutorial/swift/swift-classes"
          target="_blank"
          >Swift syntax for classes and instances</a
        >, a set of class descriptions is needed. The set selected for your
        perusal describes a very simplified stock-tracker for an imagined
        pharmaceutical company. Several classes are included in this set. These
        include a <kbd>Date</kbd> class storing individual numbers for a day,
        month, and year; a <kbd>medication</kbd> class that is the parent class
        for two medication types-- <kbd>TabletMedications</kbd> and
        <kbd>LiquidMedications</kbd>. And last, but not least, a model class (<a
          href="https://www.youtube.com/watch?v=FCkDEHWDATI"
          >MVC</a
        >) called <kbd>PharmaceuticalStockTracker</kbd> that stores and
        manipulates data regarding the stock available for sale.
          </p>
        <figure>
          <img
            src="images/W3UML1.svg"
            alt="An image showing each of the classes: Date, MedicationContainer, Liquid Medication Container, Tablet Medication Container, and Pharmaceutical Stock Tracker, their properties, and the relationships between them"
          />
          <figcaption>
            Fig.1 - A UML Class  Diagram for the Date, MedicationContainer, LiquidMedicationContainer, 
            TabletMedicationContainer, and PharmaceuticalStockTracker
            classes.
          </figcaption>
        </figure>
      <p>
        In the diagram, the arrows on lines represent is-a relationships as described below. 
        The circles on the lines represent has-a relationships.
      </p>
          
      <h2>The Date Class</h2>
      <p>
        The purpose of the <kbd>Date</kbd> class is to store the day, month, and
        year for any specific date. In a real app, you'd never create this
        class. Instead you'd use the
        <a href="https://developer.apple.com/documentation/foundation/date">
          standard Swift date structure</a
        >. Be flexible. The purpose of this custom <kbd>Date</kbd> class is to
        help you learn how to write a simplistic Swift class.
      </p>
      <p>
        The design of the <kbd>Date</kbd> class allows other code to compare
        dates by comparing any or all of these three values. If you look at the
        <a
          href="https://www.visual-paradigm.com/guide/uml-unified-modeling-language/uml-class-diagram-tutorial/"
          target="_blank"
          >UML class diagram</a
        >, it shows the <kbd>Date</kbd> class is composed of three integers--one
        for the day, one for the month, and one for the year. In the code
        snippet below the class declaration for <kbd>Date</kbd> starts with the
        keyword <kbd>class</kbd>.
      </p>

      <pre><code>class Date{
    //don't write getters and setters.
    let day:Int
    let month:Int
    let year:Int
    //each non-Optional property must be set using an initialization method
    init(aDay:Int, aMonth:Int, aYear:Int){
        day = aDay
        month = aMonth
        year = aYear
    }
}
</code></pre>

      <p>
        Notice that there are the three properties, <kbd>day</kbd>,
        <kbd>month</kbd>, and <kbd>year</kbd>, followed by an initialization
        function. When you create an instance of the <kbd>Date</kbd> class, the
        initialization function is called. Since
        <a
          href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html"
          target="_blank"
          >init is a special type of function</a
        >, you don't have to put <kbd>func</kbd> in front of it. The compiler
        will figure it out for you.
      </p>
      <p>
        Don't make the mistake of thinking you can have only one init method.
        You can have as many variations of an init function as you want. You
        could have an init function for date that has no parameters, a default
        init function, where you set the values to be some known value like
        January first 1970, the beginning of what is called the unix epoch. Or
        maybe you only want to pass some of the parameters and set the rest. You
        can add as many as make sense and that help keep the code that uses your
        class clean.
      </p>
      <p>
        How do you instantiate a class? Excellent question. Here is a code
        snippet that creates an instance of Data and a variable for the instance
        given the way the init function is declared.
      </p>

      <pre><code>let birth = Date(aDay: 16, aMonth: 11, aYear: 1990)
</code></pre>

      <p>
        Since init functions are functions, you could use the ignore operator
        for each of the parameters. Should you? Only if doing so makes the code
        clearer. In this case, I don't think it does.
      </p>
      <p>
        How do you access the properties? Another great question. Like this.
      </p>
      <pre><code>print(birth.day)
</code></pre>
      <p>Or if you want to print out something fancy,</p>
      <pre><code>print("They were born on \(birth.day)\\\(birth.month)\\\(birth.year)")
</code></pre>

      <p>
        When
        <a
          href="https://stackoverflow.com/questions/30671000/how-can-i-add-variables-into-a-stringswift"
          target="_blank"
          >embedding a value in a string</a
        >
        the <kbd>\()</kbd> operator is used. Notice that the second and third
        embedded values are proceeded by <kbd>\\</kbd>. That's there for one
        reason only. I wanted a <kbd>\</kbd> character between the parts of the
        date. Therefore, since the <kbd>\</kbd> character has a specific meaning
        in the context of a string, I had to
        <a href="https://en.wikipedia.org/wiki/Escape_character" target="_blank"
          >'escape'</a
        >
        the <kbd>\</kbd> character so it would be interpreted as a regular-old
        character.
      </p>
      <p>
        But what if you want to modify one of these properties? To do this,
        imagine that, instead of <kbd>let</kbd>, <kbd>var</kbd> was used for
        each of the properties. Then you could modify the birth
        <kbd>Date</kbd> like this.
      </p>

      <pre><code>birth.year = 2005
</code></pre>

          <p>
            Now, for those who are in the know, it may seem like the properties of
            this class are public. They are not. Instead, the compiler will create
            the accessors and mutators for you! You can create your own if you want
            or need greater control, but unlike some other languages, yes I'm
            looking at you C++ and Java, you don't have to if you don't need to.  Note 
            that you must use var if you want to allow a property to be modified. If 
            you use let, Swift only creates an accessor for you and not a mutator.
          </p>
          <p>
            For the assignments, please remember to use the built-in Date class. You 
            will need to look at 
            <a href="https://developer.apple.com/documentation/foundation/date">
              the documentation</a> 
              to learn how to create and use Dates. 
          </p>

          <h2>Computed Properties</h2>
          <p>
            In addition to variable or constant values as properties. Swift allows for             <a
              href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html"
            >computed properties</a
              >. After the property type you put braces { } and inside those braces you put either
              <kbd>get { closure }</kbd> or <kbd>set { closure }</kbd> or both where <kbd>closure</kbd> represents code that does the 
              get or set action. Here is an example of a computed property for the 
              <kbd>PharmadeuticalStockTracker</kbd> type:
              </p>
              <pre><code>class PharmadeuticalStockTracker {
    var inStockMedications: [MedicationContainer] = []
    var containerCount: Int {
        get { inStockMedications.count }
    }
}</code></pre>
              
      <h2>HAS-A Inheritance</h2>
      <p>
        Like all languages that allow Object Oriented application design, Swift
        supports
        <a
          href="https://stackoverflow.com/questions/2218937/has-a-is-a-terminology-in-object-oriented-language"
          >HAS-A type inheritance</a
        >. As an example, look at the Medication class below (see the UML class
        diagram above for an overview). The medication class represents a bottle
        of medication in the pharmacy. It HAS-A instance of
        <span class="file_name">Date</span> that represents the expiration date
        of this bottle of medication. You can see in the code snippet below that
        there is an instance property called expirationDate. Its type is Date.
        That's it. That's all you have to do to use the HAS-A type of
        inheritance. Also, if needed, you can have instance variables that are
        arrays of custom types like Dates.
      </p>

      <pre><code>class MedicationContainer {
    let id = UUID().uuidString
    let name: String
    let expirationDate: Date
    // Each non-Optional property with no default value
    // must be have a value set by an initialization method
    init(name: String, expirationDate: Date) {
        self.name = name
        self.expirationDate = expirationDate
    }
}
</code></pre>

      <p>
        It is also common for there to be some sort of container that holds
        multiple instances of a class in a HAS-A relationship. The
        <kbd>PharmaceuticalStockModel</kbd> class has such a relationship as
        seen in the earlier UML diagram and this code snippet.
      </p>

      <pre><code>class PharmaceuticalStockTracker {
    var inStockMedications:[MedicationContainer] = []
    //other properties here
    
    //init and other methods go here
}
</code></pre>

      <h2>IS-A Inheritance</h2>
      <p>
        <a
          href="https://learnappmaking.com/swift-inheritance-subclassing-how-to/"
          >IS-A inheritance is done differently</a
        >. The snippet below contains the code for both the
        <kbd>LiquidMedication</kbd> and the <kbd>TabletMedication</kbd> classes.
        They both have IS-A relationships with the <kbd>Medication</kbd> class
        and are subclasses of it. Also, they are child classes of the parent
        class <kbd>Medication</kbd>. They are derived classes of the
        <kbd>Medication</kbd> base class. These statements all mean the same
        thing. Because they are a derived classes without very much added to the
        base class, you see very little in the source code for the
        <kbd>LiquidMedication</kbd> and <kbd>TabletMedication</kbd> source code.
      </p>

          <pre><code>class LiquidMedicationContainer: MedicationContainer {
    let volume: Double
    let concentration: Int
    let concentrationUnits: String

    init(volume: Double, concentration: Int, concentrationUnits: String,
                                  name: String, expirationDate: Date) {
        self.volume = volume
        self.concentration = concentration
        self.concentrationUnits = concentrationUnits
        super .init(name: name, expirationDate: expirationDate)
    }
}
            
class TabletMedicationContainer: MedicationContainer {
    let pillCount: Int
    let potency: Double
    let potencyUnits: String
            
    init(pillCount: Int, potency: Double, potencyUnits: String,
                                  name: String, expirationDate: Date) {
        self.pillCount = pillCount
        self.potency = potency
        self.potencyUnits = potencyUnits
        super .init(name: name, expirationDate: expirationDate)
    }
}
</code></pre>

      <p>
        The most interesting parts of the snippet are the use of the
        <kbd>:</kbd> character to indicate inheritance, and the use of the
        <kbd>super</kbd> keyword to call the init method of the
        <kbd>Medication</kbd> class. If a child class has properties 
        that need to be initialized, the initializer should set those up 
        first and then use the <kbd>super</kbd> keyword to call the 
        <kbd>init</kbd> method of the class.
      </p>
          <p>
            An important point to notice about this data model is that while
            the parent class <kbd>MedicationContainer</kbd> defines the common properties 
            and shared methods for both <kbd>LiquidMedicationContainer</kbd> and
            <kbd>TabletMedicationContainer</kbd>, it does not make any sense to create
            objects directly from the parent Type. And although 
            <kbd>inStockMedications</kbd> claims to store only
            MedicationContainers, in reality it will store a combination of
            LiquidMedicationContainers and TabletMedicationContainer and
            should never contain an object created directly from the parent Type.
          </p>
      <h2>IS-A Inheritance By Extension</h2>
      <p>
        There is another very cool way to do what is usually done in other
        languages by inheritance. In Swift you can add to an existing class
        without inheriting from it. This is very handy when you are using a
        library someone else has written and need to augment that class.
        Inheritance doesn't really fit this situation because it's not feasible
        for you to go into the library source code, inherit from the base class,
        and then replace all of the base class's uses. Nor is it feasible to
        update the source code for the base class itself. While it may be you
        are prohibited from doing this because the library is closed source,
        there is a more important reason not to make changes to the library. You
        will insert new bugs.
      </p>
      <p>
        To support the pattern of augmentation, Swift has the concept of
        <a
          href="https://blog.logrocket.com/swift-extensions-an-overview-with-examples/"
          target="_blank"
          >extensions</a
        >. You can extend any class written by anyone. You could extend Swift's
        standard String class with a JSON parsing function if you wanted to. You
        could extend the Array class with a function to send the Array across
        the Internet if you wanted to. What you do is left up to you and your
        wisdom. The only restriction is you can't add stored properties to a
        class.
      </p>
      <p>
        Let's say someone wanted to extend your
        <kbd> TabletMedications</kbd> class to allow it generate a string that
        was its description. The snippet below is how they could do this.
      </p>

      <pre><code>//an extension of the TabletMedication class
extension TabletMedicationContainer {
    func getDescription() -> String {
        "['name':'\(name)', 'expirationDate':'\(expirationDate)', 
        'pillCount':'\(pillCount)', 'potency':'\(potency)', 'units':'\(potencyUnits)']"
    }
}
</code></pre>

      <p>
        As you can see, it doesn't take much code to create an extension. It's
        much less than inheritance requires. It is so easy that many programmers
        may start to overuse it. Once again, be wise. Use it when it makes your
        code easier to read and when it lets you write less code.
      </p>

          <h2>UUID and Unique Objects</h2>
          <p>
            It is possible that we may have several containers of the same 
            medication with the same expiration date. If we create separate 
            objects for each container, but they have identical properties, 
            how do we distinguish them and not think they may refer to the 
            same medication container? Swift has a built-in type called <kbd>UUID</kbd>. 
            If we put <kbd>let id = UUID().uuidString</kbd> in our class to define the
            <kbd>id</kbd> property and it will be a unique identifier for each distinct 
            object. When you are doing your assignments, if a task calls for a unique id 
            in a class or struct, be sure to include that definition and default value.
          </p>
      
          <h2>Protocols</h2>
      <p>
        In many languages, if you want to allow a developer to create a new
        class or other object that will be used by library functions or other
        existing classes, you make sure it has all needed characteristics by
        require it to be a child of an existing class that meets those
        characteristics. Swift adds a concept called
        <a
          href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html"
        >
          protocols</a
        >
        that specify the requirements that a class and certain other language
        elements must have for a particular situation. When specifying a new
        class that you want to be able to be used in certain ways, you include
        the protocol name in the class definition and then the complier makes
        sure that you actually implement the needed functionality.
      </p>
      <p>
        To indicate that SomeClass is child of SomeSuperclass and also confirms
        to two protocols you would write it like the following. You do not need
        to have a super class, but if you do, it is listed before the protocols in
        the first line of the class definition.
      </p>

      <pre><code>class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {
  // class definition goes here
}</code></pre>

          <p>
            For example, a protocol can require that a class have specific properties 
            like this:
          </p>
          
          <pre><code>protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}</code></pre>

          <p>
            This would require the class to have property names mustBeSettable and 
            doesNotNeedToBeSettable and the { get set } on the first property means 
            that property must be able to be set (which usually means it should have 
            the var keyword in front ot it). The second property could be specified 
            with let or var. Note a the protocol always used var for properties and 
            then uses the { get set } or { get } to indicate whether they need to be 
            mutable. And if you specify { get } it does not require that the property 
            be immutable, only that it may be mutable or immutable.
          </p>
          <p>
            A protocol can also require that a class implement specific methods 
            like this:
          </p>
          <pre><code>protocol RandomNumberGenerator { 
    func random() -> Double 
}</code></pre>
      <p>
        Conforming to a protocol can make certain language features or built-in 
        functions available to you.For example, if you create a new struct or 
        class that confirms to the
        <a href="https://developer.apple.com/documentation/swift/sequence"
          >Sequence protocol</a
        >, you are able to take advantage of built-in functionality that uses
        that protocol without needing to make that a child class of some parent
        to get the functionality. An object that conforms to the Sequence
        protocol can automatically be used as the source in a for…in loop. There 
        is an example of that in the tasks provided for you to use in this week's 
        assignment. To conform to a protocol, search the documentation for that protocol.
      </p>
          <p>
            The official documentation for a protocol always contains a section 
            about how to conform. For example, the documentation for the Sequence 
            protocol indicates that your class must either implement a function 
            that generates an Iterator or else your class must also explicitly 
            say it conforms to the IteratorProtocol (becoming its own iterator). 
            Once you add IteratorProtocol to the definition of your class, you can 
            look up how to confirm to that protocol. Sometimes protocols inherit 
            from other protocols so conforming to a protocol automatically requires 
            you to conform to another protocol. For example, since the
            <a href="https://developer.apple.com/documentation/swift/hashable"
            >Hashable protocol</a
              > inherits from the 
              <a href="https://developer.apple.com/documentation/swift/equatable"
              >Equatable protocol</a
              > you must also conform to anything that protocol requires.
              </p>

      <h2>Class Alternatives</h2>
      <p>
        While classes can sometimes be exactly what you need to solve a problem,
        it is always good to have alternatives. Swift has two major alternatives
        you can pick when you don't need all of the abilities, overhead, and
        baggage that go with classes in any computer language.
      </p>
      <h3>Structures</h3>
      <p>
        <a
          href="https://www.tutorialspoint.com/swift/swift_structures.htm"
          target=""
          >Structures</a
        >
        are a
        <a
          href="https://en.wikipedia.org/wiki/Value_type_and_reference_type"
          target="_blank"
          >value-type</a
        >. In other words, when they are passed to a function a copy is made and
        passed in. This differs from instances of classes where a reference to
        the instance is passed. It can be very nice to have a copy made for you
        when you need one. For example when you are passing data to be used in
        <a href="https://en.wikipedia.org/wiki/Concurrent_computing"
          >concurrent computing</a
        >. Also, structures use less RAM than instances of classes do. There are
        many
        <a
          href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html"
          >features that classes and structures have in common</a
        >. In many ways they can be used interchangeably.
      </p>
          <p>
            One caution is that since structs are passed by value, parameters that
            are structs are considered constant within a function unless you explicitly 
            make them mutable with the inout keyword as taught last week. Classes are
            automatically mutable since a reference to the object is passed to the function.
          </p>
    
      <p>Let's refactor the <kbd>Medication</kbd> class to be a structure.</p>

      <pre><code>struct MedicationContainer {
    let id = UUID().uuidString
    let name: String
    let expirationDate: Date
}
</code></pre>
      <p>
        Notice that there is no <kbd>init</kbd> function in the snippet above.
        Just like the compiler generates getters and setters, it also generates
        an init function for you with a parameter for each property. You can
        write one if you need to do some extra data validation, but you don't
        have to. This is another difference between classes and structures.
      </p>
      <p>
        In other ways, structures and classes are very similar. HAS-A types of
        inheritance are supported for structures but you can not use IS-A
        inheritance. You can, however, conform to
        <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html"
          >protocols</a
        >
        as described above which lets structs and the functions they contain be
        used in places that would usually require classes and inheritance.
      </p>
      <p>
        Swift structs can also contain methods, unlike structs from other
        languages. This allows you to use structs in many places where an object
        needs methods, but inheritance is not required. Other languages would 
        require the overhead of a class every time you want object methods.
      </p>
      <p>
        You can also extend structures. If structures most closely fit your use
        case, you should use them. Generally you should always start with a
        struct until it no longer works for your use case. You should also feel
        free to mix and match classes and structures. You don't have to use just
        one of these types in an application.
      </p>

      <h3>Tuples</h3>
          <p>
            Often we would like to return more than one value from a function, 
            such as an error code and a result. One way we can at least affect 
            more than one value is to take advantage of the fact that classes 
            are passed by reference and are mutable or else to use the “inout” 
            keyword before a parameter name to force it to be passed by reference. 
            In most languages, the typical approach is to create a structure to 
            use for the return value of a function. That works well except that 
            you are then cluttering up your code with extra structures for each 
            function that are only used to get around that language limitation 
            or else you wind up specifying a single structure returned by several 
            functions that each only may need part of it and that must then be 
            synchronized when any function wants to return an additional value.
          </p>
      <p>
        Swift addresses this need with 
        <a href="https://www.geeksforgeeks.org/swift-tuples/" target="_blank"
        >tuples</a
          >. If you want to return a Bool, an Int and a String from a function you 
          just write <kbd> -> (Bool, Int, String)</kbd>. This list of values inside 
          ( ) is called a tuple. Tuples are available in some other languages with 
          similar features. As in those other languages, tuples are a restricted 
          type. In other words IS-A inheritance and extensions are not applicable 
          to tuples. Also, tuples don't have property names. All they really do is 
        keep associated yet independent pieces of data together.
      </p>
      <p>You create a tuple by the process of composition. For example, here is a function that returns a tuple:</p>

          <pre><code>func tupleGenerator() -> (Bool, Int, String) {
    return (true, 7, “Here”)
}
</code></pre>
            <p>
              You can also create a tuple by assigning it to a variable or constant.
            </p>


          <pre><code>//composing a tuple and assigning it to a variable
let person = ("Jenny",23, 5.5)
</code></pre>
          <p>
            You can refer to elements of a tuple using <kbd>.0</kbd>, <kbd>.1</kbd>, <kbd>.2</kbd> like this:
          </p>
          <pre><code>print(person.0)</code></pre>
          <p>
            As usual, if you want to later modify the values you extract from a tuple 
            you would use var rather than let. In that case you can use the dot notation 
            to modify the tuple as well like this:
          </p>
          <pre><code>var person = ("Steven",23, 5.5)
person.0 = “John”</code></pre>
        <p>
        Most of the time you will 
        use decomposition to retrieve the individual values. In this you use let or var and 
        a list of variables in ( ) that will receive the values from the tuple like this:
      </p>

      <pre><code>//decomposing a tuple to get each stored value
let (name,age,height) = person
</code></pre>

      <p>
        If you don't need all the values, you don't have to create variables for
        them via decomposition.
      </p>
      <p>
        For example, if all you needed was the age of a person tuple, you could
        decompose the person tuple like this.
      </p>
      <pre><code>//decomposing a tuple using the ignore operator
let (_,age,_) = person
</code></pre>

          <h2>Any, AnyObject, is, and as?</h2>
          <p>
            Swift’s tight control of Types is usually great, but sometimes you may 
            need to allow a variable, a class or structure property or an array 
            element to have more than one Type. If you specify that something 
            has the type <kbd>Any</kbd>, you can put anything into it including a class, 
            a struct, an array or a basic type like an <kbd>Int</kbd>, a <kbd>Bool</kbd> or a <kbd>String</kbd>. 
            You can also specify <kbd>AnyObject</kbd> which will limit what you can put into 
            it to any class object. You can think of <kbd>AnyObject</kbd> as the automatic 
            parent (or great, great… grandparent) of all all classes.
          </p>
          <p>    
            Once you have something of type <kbd>Any</kbd> or <kbd>AnyObject</kbd>, you can 
            check what is in it by using the “is” operator followed by a Type. This will 
            return true if the item is of that Type or, for class objects, is an instance 
            of that Type or of a child of that Type. This also allows you to store class 
            objects in a variable or parameter of the parent type and find out what type 
            they are later. Using the model diagram for MedicationContainers here are some 
            examples:
            <pre><code>let container1: MedicationContainer = MedicationContainer(name: "SomeMed", expirationDate: aDate)
let container2: MedicationContainer = LiquidMedicationContainer(volume: 2.1, concentration: 4, 
                    concentrationUnits: "mg", name: "AnotherMed",  expirationDate: aDate)
let any1: AnyObject = MedicationContainer(name: "SomeOtherMed", expirationDate: aDate)
let any2: AnyObject = TabletMedicationContainer(pillCount: 30, potency: 3.0, potencyUnits: "mg", 
                    name: "TabletMed",  expirationDate: aDate)

print(container2 is LiquidMedicationContainer) // returns true
print(container1 is LiquidMedicationContainer) // returns false

print(any1 is MedicationContainer)  // returns true
print(any2 is MedicationContainer)  // returns true
print(any2 is TabletMedicationContainer) // returns true
print(any2 is LiquidMedicationContainer) // returns false
print(any1 is TabletMedicationContainer) // returns false
</code></pre>
<p>
            It’s great to know whether an object of Type <kbd>Any</kbd> really contains a 
            LiquidMedicationContainer, but how do we access the properties and methods of 
            that object? The <kbd>as?</kbd> operator allows us to try to pull an object 
            out of a variable. The <kbd>?</kbd> reminds us that this returns an optional 
            since the conversion might fail and produce <kbd>nil</kbd>. There is a <kbd>as!</kbd> 
            operator, but like the <kbd>!</kbd> operator, you should not use it in this course. 
</p>
<p>    
            Note that <kbd>as?</kbd> only “actualizes” the underlying type. It does not do type 
            conversion. Suppose <kbd>myAnyInt</kbd> is a variable of Type <kbd>Any</kbd> that 
            happens to contain an <kbd>Int</kbd>. If you want to store that into a <kbd>Double</kbd> 
            called <kbd>myDouble</kbd> you may be tempted to write 
            <kbd>let myDouble = myAnyInt as? Double</kbd>, 
            but that will fail since the underlying type is not a <kbd>Double</kbd>. Instead, 
            you would need to write it like this: <kbd>let myDouble = Double(myAnyInt as? Int)</kbd> 
            and if you thing the <kbd>Any</kbd> contains an <kbd>Int</kbd> or a <kbd>Double</kbd> 
            you need to write slightly more complicated code to extract it to a <kbd>Double</kbd>. 
            You will have the opportunity to figure out how to do that in the assignment 
            this week.

  <h2>Access Control</h2>
      <p>
        There are times when you need more control over when and who can access
        parts of your code. To ease this situation Swift also has the concept of
        <a
          href="https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html"
          target="_blank"
          >Access Control</a
        >. This is similar to what is found in most other modern programming
        languages. Using the file private access control, you can have
        variables, functions, classes and their instances, or any other Swift
        language type in a regular swift file and anything you don't want to
        allow access to from other swift code files, you mark as private. Thus
        they become 'file private', i.e. they can only be used within the file.
      </p>
      <p>
        File privacy is very handy when you want to expose only certain
        functions, classes, etc. for use in other source files. For example, the
        <kbd>MedicalStockTracker</kbd> class could be replaced with a file.
      </p>
      <pre><code>private var inStockMedications = [MedicationContainer]()
func addLiquidMedicationToStock(medicationToAdd:LiquidMedicationContainer) {
  .
  .
  .
}
//other public functions here
  .
  .
  .

  
private func validateExpirationDate(aDate:Date)->Bool {
  .
  .
  .
}</code></pre>
      <p>
        Anything that is not to be accessed outside of the file must have the
        keyword <kbd>private</kbd> in front of the rest of the declaration. In
        the example above you will see two <kbd>private</kbd> items. The first
        is the list of medications used to store the current medication stock.
        The second is a helper function that isn't for use outside of the
        module.
      </p>
      <p>
        File privacy is a handy way to create API's for others and yourself to
        use latter, in other code.
      </p>
      <h2>Wrap Up</h2>
      <p>
        You have many options when it comes to representing the data your
        application works on and with. Make your choices wisely. Each of the
        types described in this reading were created for a purpose. Use the one
        that fits. You should also use the 'least' one that fits. For example,
        if you could use a tuple, a structure, or a class to represent some data
        you should use a tuple. If only structure or class would fit the need,
        use a structure. If only a class fits, use a class.
      </p>
      <p>
        If you follow this 'least required' decision pattern, your code will be
        leaner and have fewer bugs.
      </p>
    </main>
    <footer>
      <a
        rel="license"
        href="http://creativecommons.org/licenses/by/4.0/"
        target="_blank"
        ><img
          alt="This work is licensed under a Creative Commons Attribution 4.0 International License"
          style="border-width: 0"
          src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a
      ><br />This work is licensed under a
      <a
        rel="license"
        href="http://creativecommons.org/licenses/by/4.0/"
        target="_blank"
        >Creative Commons Attribution 4.0 International License</a
      >.
    </footer>
  </body>
</html>
        